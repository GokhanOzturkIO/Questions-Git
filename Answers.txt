1- Git Nedir?

Git bir VCS (Version Control System) yani versiyon kontrol sistemi olarak tanımlanır. Peki versiyon kontrol sistemi nedir?
Versiyon kontrol sistemi bizim için adeta bir kayıt defteri ya da buluta alınmış bir yedek olarak özetlenebilir. VCS'ler sayesinde
projemizde yaptığımız değişikler hem takımımız tarafından görülebilir hem de bizler projeyi geliştirirken hata yaparsak bir önceki
ya da herhangi istediğimiz bir zamandaki kayda dönebiliriz.

******************************************************************************************************************************************************

2- "git pull" ile "git fetch" komutlarının farkı nedir?

Temelde her ikisi de repodan güncellemeleri almak için kullanılır. Aralarındaki fark ise fetch komutu güncellemeleri alır ancak local çalışma alanını güncellemez,
ancak pull komutu ile değişiklikleri alınır ve local çalışma alanınıyla senkronize eder.

******************************************************************************************************************************************************

3- Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?

Bu sorunun birden fazla nedeni olabilir bu nedenle farklı senaryoları inceleyelim. İlk olarak arkadaşınız kodları yalnızca commitleyerek staging area'ya almış olabilir.
bir diğer sebep yanlış repository üzerinde çalışıyor olabilirsiniz(aynı durum takım arkadaşınız için de geçerli) veya çalıştığınız repository üzerinde yetkiniz olmayabilir ya da repository adresi değişmiş olabilir. Bu gibi sebepler nedeniyle hata alıyor olabilirsiniz bu durumda git fetch komutunu deneyip tekrar sonuç alamazsanız yukarıkdaki
seçenekleri deniyebilirsiniz.

******************************************************************************************************************************************************

4- "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?

origin burada varsayılan branch ismi olarak kullanılmıştır. Burada eğer farklı branch üzerinde çalışıyorsak ve bu branch'teki değişiklikleri almak istiyorsak
komutu git fetch branch_adı şeklinde de kullanabiliriz.

******************************************************************************************************************************************************

5- "HEAD" kelimesi neyi temsil etmektedir?

Hangi commit'te olduğumuzu gösteren ifadeye denir. Varsayılan olarak en son atılan commit HEAD olur ancak checkout ile başka bir commit'e gidilirse bu yeni geçilen
commit HEAD olur. git log komutunu kullandığımızda güncel olarak hangi commit'te bulunuyorsak o commit'in yanında parantez içerisinde HEAD -> branch_adı
şeklinde bir gösterim bulunur.

******************************************************************************************************************************************************

6- "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?

Staging Area, değişikliklerimizi commit etmeden önce hazırladığımız geçici bir alandır. Değişik yaptığımız dosyaları git add komutu ile staging area'ya ekleyerek,
bu dosyaları bir sonraki commit'te dahil etmek istediğimizi belirtmiş oluyoruz. Bu alan sayesinde projemizde commit öncesi yaptığımız değişiklikleri kontrol etme
ve düzeltme imkanına sahip oluyoruz.

******************************************************************************************************************************************************

7- "Untracked file" ne demektir?

Untracked file, Git tarafından izleme altına almadığı dosyaları tanımlar. Bu dosyalar üzerinde yapılan değişiklikler git sistemine henüz eklenmemiştir.
ilk olarak git add komutu ile bu dosyaları izleme altına alabilir akabinde daha sonra git commit -m "commit mesajı" ile staging area'ya dahil edebiliriz.

******************************************************************************************************************************************************

8- ".git" klasörünü silersek ne olur?

Bu klasör git deposunun tüm bilgilerini içeren önemli bir klasördür. Bu klasörü silerseniz, Git deposu ile ilgili tüm verileri kaybedersiniz.
.git klasörünü silmek depoyu tamamen yok etmek anlamına gelir ve geri dönülemez kayıplara neden olur.

******************************************************************************************************************************************************

9- Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?

Bunun için git'in bize sunduğu template özelliğini kullanmamız gerekli. Bu özellik sayesinde yeni bir git dosyası oluşturulduğunda yapılacak işlemleri
tanımlayabiliriz. Template özelliğini kullanmak için şu adımları izleyebiliriz.

a. İlk olarak Git'in yüklü olduğu dizini açmamız gerekli (Windows için C:\Program Files\Git\) daha sonra \share\git-core\templates dizinine gitmemiz gerekli
b. Bu dizine girdikten sonra hooks adlı klasörü bulmamız gerekli eğer mevcut değilse kendimiz oluşturabiliriz.
c. hooks klasörünün içine girerek init.sh isimli bir dosya oluşturmalıyız.
d. init.sh dosyasını herhangi bir metin düzenleme uygulaması ile açalım ve 
	#!/bin/sh
	touch README.md
   kodunu ekleyelim.
   bu kod sayesinde her yeni repo oluşturduğumuzda readme dosyası otomatik olarak oluşturulacaktır.
e. Son olarak bu dosyaya yetki vermemiz gerekli bulunduğumuz dizinde terminal açalım ve "chmod +x init" komutu ile yetkilendirme işlemini yapalım.

******************************************************************************************************************************************************

10- Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?

Branch kelime anlamı olarak "Dal" demektir, projelerimizi dallara ayırmamızı sağlar. Projemize eklemek istediğimiz bir feature'ın ana repository
etkilemesini istemiyorsak yeni bir branch açıp geliştirme işlemlerimizi bu branch üzerinde yaparız bu şekilde ana projeyi olası hatalara karşı korur
ve geliştirme sürecinde çalışmaya devam etmesini sağlayabiliriz. Ayrıca paralel geliştirme imkanını da bizlere sağlar.

******************************************************************************************************************************************************

11- Sıfırdan bir "branch" nasıl oluşturabiliriz?

Yeni bir branch oluşturmak için "git checkout -b brach_adı" komutu kullanılabilir.

******************************************************************************************************************************************************

12- Var olan bir "branch"e nasıl geçebiliriz?

Var olan bir branch'e geçiş yapmak içim "git checkout branch_adı" komutu kullanılabilir.

******************************************************************************************************************************************************

13- "git clone" komutunu kullanırken belirli bir spesifik branch'i sadece çekmek istiyorsak nasıl yapabiliriz?

Belirli bir branch'i çekmek için "git clone -b branch_adı <repository_urlsi>" veya "git clone --branch branch_adı <repository_urlsi>"

******************************************************************************************************************************************************

14- "Merge conflict" ne demektir?

Git üzerinde farklı dallardaki değişikliklerin birleştirilmeye çalışıldığında ortaya çıkan duruma denir. İki veya daha fazla dalda yapılan değişikler,
çakışması veya uyumsuz olması durumunda, Git otomatik olarak bu değişiklikleri birleştirmeye çalışırken bir çakışma meydana gelir.
Merge conflict genelde şu durumlarda ortaya çıkar;

a. İki farklı dalda aynı satırda yapılan değişiklikler.
b. Bir dalda yapılan değişiklikler, diğer dalda tamamen silinmiş olan dosyaları veya satırları içeriyor.
c. İki dalda da aynı ada sahip fakat içeriği farklı dosyaların değiştirilmesi

gibi sorunlar sebebiyle ortaya çıkabilir.

******************************************************************************************************************************************************

15- "git log" komutu ile hangi bilgileri görebiliriz?

Git log komutu, bir Git reposundaki commit geçmişini görmemizi sağlar. Git log komutu ile şunları görüntüleyebiliriz.

a. Commit ID
b. Commit'i Yazan kişi
c. Tarih ve saat
d. Commit mesajı
e. Değişiklikler

******************************************************************************************************************************************************

16- "git diff" ile kaç farklı iki durumun arasındaki değişiklikleri görebiliriz?

Bu komut ile iki farklı durum arasındaki değişiklikleri inceleyebiliriz.
Genel kullanımda en çok incelenen değişiklikler şunlardır;

a. Çalışma dizini ile Staging alanı arasındaki farklar -> "git diff"
b. Staging area ile son commit arasındaki farklar -> "git diff --staged"
c. İki farklı commit arasındaki farklar -> git diff <commit_id1> <commit_id2>

******************************************************************************************************************************************************

17- Git reset ile neyi geri alıyoruz?

Git reset komutu ile git reposundaki değişiklikleri geri almak veya geçmişteki bir duruma dönmek için kullanılır.
En sık kullanılan git reset komutları şu şekildedir;

a. Dosyaları staging area'dan geri almak -> "git reset dosya_adı"
b. Commit'i geri almak (commit bilgilerini koruyarak) -> "git reset --soft HEAD"
c. Commit'i geri almak (commit bilgilerini ve değişiklikleri geri alarak) -> "git reset --mixed HEAD~1"
d. Commit ve değişiklikleri geri almak (bu komut değişiklikleri tamamen geri alır) -> "git reset --hard HEAD~1"

******************************************************************************************************************************************************

18- "git commit" ile "git push" arasındaki fark nedir?

Git commit komutu çalışma dizinindeki değişiklikleri değişiklikleri yerel depoya kaydeder. Git push ise yerel depodaki değişiklikleri uzak depoya
göndermek için kullanılır. Yani commit ile yerel depoya kayıt push ile uzak sunucuya kayıt işlemini yaparız.

******************************************************************************************************************************************************