1.Git Nedir?


Git, yazılım geliştirme projelerinde kullanılan dağıtık bir versiyon kontrol sistemi (VCS)dir. Linus Torvalds tarafından Linux kernelinin geliştirilmesi için başlatılmıştır. Git, projenin tüm geçmişini saklar ve her bir değişikliği takip eder. Geliştiricilerin eşzamanlı olarak bir projede çalışmasına, değişikliklerin takip edilmesine, geri alınmasına ve karşılaştırılmasına olanak tanır.

Git'in bazı temel özellikleri şunlardır:

Dağıtık Yapı: Her kullanıcı, projenin tam bir kopyasını alır ve kendi bilgisayarında çalışır. Bu sayede çevrimdışı olarak da çalışılabilir ve bağımsız olarak değişiklikler yapılabilir.

Hızlı İşlem: Git, verileri sıkıştırır ve depolar, bu nedenle hızlıdır. Büyük projeleri yönetmek için uygundur.

Güvenilirlik: Git, veri bütünlüğünü sağlamak için kriptografik olarak güvenli bir şekilde depolama yapar. Her değişiklik için benzersiz bir kimlik oluşturur.

Esnek Dal ve Birleştirme (Branching and Merging): Git, farklı işlevleri veya özellikleri denemek için kolaylıkla dal oluşturmayı ve ardından bu dalları ana projeye birleştirmeyi sağlar. Bu, paralel geliştirme yapmayı ve değişikliklerin etkileşimi olmadan test edilmesini sağlar.

Açık Kaynaklı ve Ücretsiz: Git, açık kaynaklı bir projedir ve ücretsiz olarak kullanılabilir. Bu, birçok geliştiricinin katkıda bulunmasını ve sistemde geliştirmeler yapılmasını sağlar.

Git, yazılım geliştirme endüstrisinde en popüler versiyon kontrol sistemlerinden biridir ve birçok büyük projede yaygın olarak kullanılmaktadır.

******************************************************************************************************************************
2."git pull" ile "git fetch" komutlarının farkı nedir?
"git pull" ve "git fetch" komutları, Git'te uzak depodan değişiklikleri almak için kullanılan iki farklı komuttur. İkisi de uzak depodaki değişiklikleri yerel depoya getirir, ancak farklı şekillerde çalışırlar ve farklı sonuçlar üretebilirler.

İşte "git pull" ve "git fetch" komutlarının farkları:

git fetch:

Bu komut, uzak depodan tüm değişiklikleri alır ve yerel depoda geçerli bir duruma getirir, ancak otomatik birleştirme işlemi gerçekleştirmez.
Alınan değişiklikler yerel depoda "origin/master" gibi referans adlarında saklanır.
Bu komut, yerel çalışma kopyasında otomatik olarak birleştirme işlemi yapmaz, bu nedenle çakışma olasılığına karşı önlem almak için kullanıcı müdahalesi gerekebilir.
İşlem tamamlandığında, kullanıcı yerel kopyayı güncellemek için manuel olarak birleştirme işlemi yapmalıdır.
git pull:

Bu komut, uzak depodan değişiklikleri alır ve yerel depoyu otomatik olarak günceller.
Öncelikle "git fetch" komutunu çağırır ve uzak depodaki değişiklikleri getirir.
Ardından, yerel depodaki mevcut dalı (veya bir dalı belirtilen bir uzak daldan) uzak daldan çeker ve yerel depo ile birleştirir.
"git pull", "git fetch" ve ardından "git merge" (veya "git rebase" kullanarak) komutlarını tek bir adımda gerçekleştirir, bu nedenle kullanıcı tarafından manuel birleştirme işlemi genellikle gerekli değildir.
Genel olarak, "git fetch" komutu değişiklikleri alır ve yerel depoda saklar, ancak birleştirme işlemi yapmazken, "git pull" komutu aynı işlemi yapar ve ayrıca yerel depoyu otomatik olarak günceller ve birleştirir.

******************************************************************************************************************************
3.Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?


Eğer takım arkadaşınızın gönderdiği kodları "git pull" ile lokal olarak alamıyorsanız, bu durumda birkaç olası hata noktası bulunabilir:

Uzak depoya erişim sorunları: Takım arkadaşınızın kodlarını almak için kullanılan uzak depoya erişim sorunları olabilir. Bu, ağ bağlantısı sorunları, yetki sorunları veya uzak depo sunucusunun erişilemez olması gibi çeşitli nedenlerle ortaya çıkabilir.

Doğru depodan çekim yapılmaması: Takım arkadaşınızın kodlarını gönderdiği ancak sizin lokal olarak çekim yapmaya çalıştığınız depo arasında farklılık olabilir. Yanlış bir depodan çekim yapmaya çalışmak, kodların alınmamasına neden olabilir.

Dal isimlendirme farklılıkları: Takım arkadaşınızın gönderdiği kodlar farklı bir dalda olabilir ve siz yanlış dala çekim yapmış olabilirsiniz. Bu durumda, kodların bulunduğu doğru dala geçiş yaparak "git pull" komutunu tekrar denemelisiniz.

Çakışan değişiklikler: Takım arkadaşınızın gönderdiği kodlar, sizin üzerinde çalıştığınız değişikliklerle çakışıyor olabilir. Bu durumda "git pull" komutu birleştirme çakışmaları nedeniyle başarısız olabilir. Çakışmaları çözmek için birleştirme işlemi gerekebilir.

Kodların gönderilmemiş olması: Takım arkadaşınız kodları göndermiş olabilir ancak sizin tarafınızdan alınmamış olabilir. Bu durumda, takım arkadaşınızın kodları gönderip göndermediğini kontrol etmek önemlidir.

Bu tür durumlarda, hata mesajlarını kontrol etmek ve hangi adımların hatalı olduğunu belirlemek önemlidir. Ardından, sorunun kaynağını belirlemek ve uygun çözümü uygulamak için adımları yeniden gözden geçirebilirsiniz.

******************************************************************************************************************************
4."git fetch origin" komutundaki "origin" neye karşılık gelmektedir?

"git fetch origin" komutundaki "origin", genellikle Git projenizin uzak depolarından birine verilen bir isimdir. Bu isim, projenin orijinal (yani kaynak) uzak depolarına atıfta bulunmak için kullanılır. "origin" terimi, projenin ana uzak deposunu temsil eder.

Bir Git projesi genellikle birden fazla uzak depoya sahip olabilir. "origin", genellikle proje sunucusunun (örneğin GitHub, GitLab veya Bitbucket gibi) ana uzak deposunu temsil eder. Ancak, bu terim isteğe bağlıdır ve projenin yapılandırmasına bağlı olarak farklı bir isimde de olabilir.

Örneğin, bir proje için birden fazla uzak depo eklemek isterseniz, her bir uzak depoya farklı bir isim verebilirsiniz. "origin" sadece bir konvansiyon olup, projenin orijinal uzak deposuna atıfta bulunmak için yaygın olarak kullanılan bir isimdir. Bu ismi değiştirmek, projenin yapılandırmasına bağlıdır ve "git fetch" komutunda kullanılan isim, projenin hangi uzak depolarına atıfta bulunmak istediğinize bağlı olacaktır.

******************************************************************************************************************************
5."HEAD" kelimesi neyi temsil etmektedir?
"HEAD", bir Git deposundaki mevcut çalışma kopyasının gösterildiği belirteçtir. "HEAD", genellikle mevcut dala (branch) işaret eder ve mevcut dalın son commit'ini temsil eder. Yani, "HEAD", projenin şu anda çalıştığı veya üzerinde çalışılan konumu işaret eder.

"HEAD" kelimesi ayrıca, Git'in içsel referanslarını temsil eden bir dosya adıdır. "HEAD" dosyası, depoda bulunan mevcut commit'in kimliğini (hash değerini) içerir. Bu dosya, genellikle .git klasörü altında bulunur.

"HEAD" belirteci, şu durumları temsil edebilir:

Bir dalın (branch) son commit'ini işaret eder.
Bir etiket (tag) üzerinde işaret eder.
Doğrudan bir commit'in kimliğini (hash değerini) işaret eder.
Yani, "HEAD", Git deposunun şu anda hangi noktada olduğunu belirtir ve çalışma kopyasının hangi commit'e dayandığını gösterir. Bu, Git'in kullanıcıya mevcut durumu göstermek ve değişiklikler yapmak için hangi commit üzerinde çalıştığını belirtmek için kullandığı önemli bir belirteçtir.

*****************************************************************************************************
6."Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?
"Staging Area" veya "Index", Git'in çalışma mantığı içinde önemli bir konsepttir. Bu bölge, Git deposundaki değişikliklerin geçici olarak saklandığı ve sonraki commit işlemi için hazırlandığı bir ara depolama alanıdır.

İşte "Staging Area" veya "Index" bölgesinin ana işlevleri:

Değişikliklerin Seçimi: Çalışma kopyasında yapılan değişiklikler, commit işlemine eklenmeden önce "Staging Area"ya eklenir. Bu, değişikliklerin hangilerinin sonraki commit işlemine dahil edileceğini seçmek için bir fırsat sağlar.

Commit Hazırlığı: "Staging Area"ya eklenen değişiklikler, bir sonraki commit işlemi için hazırlanır. Bu, commit işlemi yapmadan önce hangi değişikliklerin dahil edileceğini kontrol etmek için bir araç sağlar.

Commit Ayırma: Birden fazla değişiklik grubu veya parçalı değişiklikler, "Staging Area"ya eklenerek ayrı commit'ler olarak işaretlenebilir. Bu, daha düzenli ve anlaşılır commit geçmişi oluşturmanıza olanak sağlar.

Durum Kontrolü: "Staging Area"da hangi dosyaların değiştirildiğini, eklendiğini veya silindiğini görmek, projenin durumu hakkında bilgi sağlar. Bu, hangi dosyaların commit edileceğine karar vermek için faydalıdır.

"Staging Area" veya "Index", Git'in esnekliğini ve gücünü arttıran bir araçtır. Değişikliklerin dikkatlice seçilmesini ve organize edilmesini sağlayarak, daha düzenli ve yönetilebilir bir proje geçmişi oluşturmanıza olanak tanır.
*****************************************************************************************************
7."Untracked file" ne demektir?
"Untracked file" terimi, Git deposunun izlemediği ve takip etmediği dosyaları ifade eder. Yeni oluşturulan veya projeye henüz eklenmemiş dosyalar bu kategoriye girer.

Bir dosya "untracked" durumunda ise, Git bu dosyanın değişikliklerini izlemez ve bu dosyaların durumu deponun içinde kaydedilmez. Bu, dosyanın geçici veya test amaçlı olduğu veya depo ile ilgili olmadığı durumlar için geçerlidir.

"Untracked file" durumu, dosyanın projenin geçmişini veya sürüm kontrolü tarihçesini oluşturan dosyalar arasında yer almadığı anlamına gelir. Bu dosyalar, çalışma kopyasında yer alır ancak Git tarafından izlenmezler veya yönetilmezler.

"Untracked file" durumundaki dosyalar, projeye eklenmeden önce "git add" komutu ile "Staging Area"ya eklenmelidir. Bu işlem, dosyanın Git tarafından izlenmeye başlanmasını sağlar ve sonraki commit işlemlerine dahil edilmesine olanak tanır.
*****************************************************************************************************
8.".git" klasörünü silersek ne olur?
".git" klasörü, Git deposunun kalbidir ve projeyle ilgili tüm versiyon kontrolü bilgilerini içerir. Bu klasörü silmek, Git deposunun tüm versiyon kontrolü geçmişini ve ayarlarını kaybetmenize neden olur. Yani, ".git" klasörünü silmek, projenin Git yönetimi altındaki tüm geçmişini ve yapılandırmasını ortadan kaldırır.

İşte ".git" klasörünü silmenin bazı sonuçları:

Versiyon kontrol geçmişi kaybolur: ".git" klasörünü sildiğinizde, projenin tüm geçmişi kaybolur. Tüm commit'ler, dallar, etiketler ve diğer versiyon kontrolü bilgileri silinir.

İzlenen dosyalar kaybolur: ".git" klasörü, izlenen dosyaların ve değişikliklerin durumunu saklar. Bu klasörü sildiğinizde, izlenen dosyaların durumu kaybolur ve projeyle ilgili tüm değişiklikler gitmez.

Dal bilgileri kaybolur: ".git" klasörü, projede oluşturulan dalların ve dallar arasındaki ilişkilerin bilgisini içerir. Bu bilgiler silinir ve tüm dallar tek bir dal haline gelir.

Etiketler kaybolur: Proje içinde oluşturulan etiketler, ".git" klasöründe saklanır. Bu etiketler kaybolur ve projenin tüm geçmişindeki önemli noktaları işaretleyen referanslar kaybolur.

Yapılandırma ayarları kaybolur: ".git" klasörü, projenin Git yapılandırma ayarlarını içerir. Bu ayarlar silinir ve projenin özelleştirilmiş Git yapılandırması kaybolur.

Sonuç olarak, ".git" klasörünü silmek, projenin Git kontrolü altındaki tüm geçmişini ve ayarlarını kaybetmenize neden olur. Bu nedenle, ".git" klasörünü silmeden önce bu işlemin geri dönüşü olmadığını ve proje geçmişinin kaybolacağını unutmamak önemlidir.
*****************************************************************************************************
9.Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?
Kendi lokalimizde her "git init" komutunu kullandığımızda otomatik olarak "README.md" dosyasının oluşturulmasını sağlamak için, Git'in "template" klasöründeki varsayılan "git init" şablonunu değiştirmemiz gerekmektedir. Bu şablon dosyasını düzenleyerek, yeni bir proje başlatıldığında otomatik olarak oluşturulacak dosyaları belirleyebiliriz.

*****************************************************************************************************




