
Question 1: Git Nedir?

-> Git dağıtık bir sürüm kontrol sistemidir. Yazılım geliştirme süreçlerinde kodun yönetimini kolaylaştırmak için kullanılır.

    -> Versiyon kontolü ile projede yapılan değişiklikleri tutar ve geçmişte yaptığımız değişikleri görmemizi sağlar.
    -> Dağıtık olması ile her kullanıcının kendi kopyasına sahip olmasını ve uzak bir sunucuya gerek duyulmadan localden işelm yapmamızı sağlar.
    -> Branchler ile geliştirme sürecinde farklı özelliklerin ve değişikliklerin ayrı ayrı yönetilmesini olanak sağlar.
    -> Birden fazla geliştiricinin aynı projede çalışmasını kolaylaştırır.


Question 2: "git pull" ile "git fetch" komutlarının farkı nedir?

-> "git pull" ve "git fetch" komutları, uzak bir sunucudan değişiklikleri almak için kullanılır, ancak farklı şekillerde çalışırlar.

    -> "git fetch": Uzak sunucudaki tüm değişiklikleri local kopyamıza indirir, fakat olduğumuz branchi etkilemez. Bu komut ile aslında ilk olarak yapılan değişikliği görüp daha sonra gerekirse local branchimize birleştirmemizi sağlar.
    -> "git pull": Bu komut ile ilk olarak uzak sunucudaki değişiklikleri kopyamıza indirir ve daha sonra olduğumuz branchi günceller. Aslında buradaki işlem "git fetch" i çağırırp daha sonra otomatik olarak local branchimi güncellemizi sağlar.


Question 3: Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?

-> İnternet bağlantımızda ve Uzak sunucuya erişim sorunumuz olabilir.
-> Arkadaşımızın verdiği branch bilgisi hatalı olabilir.
-> Tanımlanmış bir commit formatı varsa ve ona uymamış ise yaptığı commit hata ile sonuçlanmış olabilir.(Örn: Commit mesajı 250 karakterden fazla olamaz)
-> Arkadaşımız commit yapıp pushlamayı unutmuş olabilir. Değişiklikler arkadaşımızın localinde vardır fakat uzak sunucuya göndermediği için bir göremiyoruzdur.

Question 4: "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?

-> Bir projenin uzak sunucudaki(remote) ana kaynağını temsil eder.


Question 5: "HEAD" kelimesi neyi temsil etmektedir?

-> "HEAD" aslında bir kısayol yani alias tır. Git'te olan mevcut çalışma durumumuzu yani bulunduğumuz branchteki en son/en yeni commiti temsil eder.


Question 6: "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?

-> Git'in commit işlemi öncesi değişiklikleri saklamamızı sağladığı bir ara alandır. Bu alan sayesinde commit etmek istediğimiz değişiklikleri seçip, düzenleyip, ekleyip ve çıkarmamıza olanak tanır. Bu sayede commit işelmelerimiz daha  kontrollü ve organize olur, sadece belirli değişiklikleri seçip düzenlememizi sağlar.


Question 7: "Untracked file" ne demektir?

-> "Untracked file" (izlenmeyen dosya), Git'in dosyaları izlemediği veya takip etmediği dosyaları ifade eder. Yani, bu dosyalar Git tarafından tanınmaz veya izlenmez.


Question 8: ".git" klasörünü silersek ne olur?

-> Geçmiş olsun :)
-> ".git" klasörü, bir Git deposunun tüm versiyon kontrolü ve diğer Git özelliklerini içeren çok önemli bir klasördür. Bu klasörü silerseniz, Gitten tüm versiyon kontrolü geçmişi ve diğer Git özelliklerini kaybetmiş olursunuz.
-> ".git" dosyanızı yanlışlıkla silmemek için, gizli dosyaları görüntülemeyi kapatabilirsiniz.


Question 9: Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?

-> İlk olarak template'imizi konumlandıracağımız bir klasör oluşturmamız gerekir.
    -> ~/.git-templates
-> Daha sonra oluşturduğumuz "README.md" dosyayı oluşturduğumuz template dizinine ekliyoruz.
-> Daha sonra her "git init --template ~/.git-templates" komutunu çalıştırdığımızda otomatik olarak Readme.md dosyası oluşmuş olacaktır.


Question 10: Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?

-> Bir projenin farklı paralel geliştirme süreçlerini yönetmek için kullanılır.

    -> Aslında her bir "branch" farklı bir işi farklı bir özelliği temsil eder. Bu da ekip üyelerinin aynı anda farklı özellikler üzerinde çalışmasına olanak tanır.
    -> Yeni bir özellik veya iş üzerinde çalışırken ana yapıyı riske atmadan geliştirmeleri ilerletmemizi sağlar.
    -> Yeni bir özelliğin live a geçmeden(son kullanıcı ile buluşmadan) gerekli testlerin yapılmasına olanak sağlar.
    -> Bir projenin farklı versiyonlarını ve sürümlerini kontrol etmeyi kolaylaştırır. Sürümlerde oluşan hataları bağımsız olarak çözmeyi kolaylaştırır.
    -> Branchlerin birbirinden bağımsız olması nedeni ile yanlış yapılan işlerde değişiklik yapılmasını ve geri alınmasını  kolaylaştırır.
