
Question 1: Git Nedir?

-> Git dağıtık bir sürüm kontrol sistemidir. Yazılım geliştirme süreçlerinde kodun yönetimini kolaylaştırmak için kullanılır.

    -> Versiyon kontolü ile projede yapılan değişiklikleri tutar ve geçmişte yaptığımız değişikleri görmemizi sağlar.
    -> Dağıtık olması ile her kullanıcının kendi kopyasına sahip olmasını ve uzak bir sunucuya gerek duyulmadan localden işelm yapmamızı sağlar.
    -> Branchler ile geliştirme sürecinde farklı özelliklerin ve değişikliklerin ayrı ayrı yönetilmesini olanak sağlar.
    -> Birden fazla geliştiricinin aynı projede çalışmasını kolaylaştırır.


Question 2: "git pull" ile "git fetch" komutlarının farkı nedir?

-> "git pull" ve "git fetch" komutları, uzak bir sunucudan değişiklikleri almak için kullanılır, ancak farklı şekillerde çalışırlar.

    -> "git fetch": Uzak sunucudaki tüm değişiklikleri local kopyamıza indirir, fakat olduğumuz branchi etkilemez. Bu komut ile aslında ilk olarak yapılan değişikliği görüp daha sonra gerekirse local branchimize birleştirmemizi sağlar.
    -> "git pull": Bu komut ile ilk olarak uzak sunucudaki değişiklikleri kopyamıza indirir ve daha sonra olduğumuz branchi günceller. Aslında buradaki işlem "git fetch" i çağırırp daha sonra otomatik olarak local branchimi güncellemizi sağlar.


Question 3: Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?

-> İnternet bağlantımızda ve Uzak sunucuya erişim sorunumuz olabilir.
-> Arkadaşımızın verdiği branch bilgisi hatalı olabilir.
-> Tanımlanmış bir commit formatı varsa ve ona uymamış ise yaptığı commit hata ile sonuçlanmış olabilir.(Örn: Commit mesajı 250 karakterden fazla olamaz)
-> Arkadaşımız commit yapıp pushlamayı unutmuş olabilir. Değişiklikler arkadaşımızın localinde vardır fakat uzak sunucuya göndermediği için bir göremiyoruzdur.

Question 4: "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?

-> Bir projenin uzak sunucudaki(remote) ana kaynağını temsil eder.


Question 5: "HEAD" kelimesi neyi temsil etmektedir?

-> "HEAD" aslında bir kısayol yani alias tır. Git'te olan mevcut çalışma durumumuzu yani bulunduğumuz branchteki en son/en yeni commiti temsil eder.


Question 6: "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?

-> Git'in commit işlemi öncesi değişiklikleri saklamamızı sağladığı bir ara alandır. Bu alan sayesinde commit etmek istediğimiz değişiklikleri seçip, düzenleyip, ekleyip ve çıkarmamıza olanak tanır. Bu sayede commit işelmelerimiz daha  kontrollü ve organize olur, sadece belirli değişiklikleri seçip düzenlememizi sağlar.


Question 7: "Untracked file" ne demektir?

-> "Untracked file" (izlenmeyen dosya), Git'in dosyaları izlemediği veya takip etmediği dosyaları ifade eder. Yani, bu dosyalar Git tarafından tanınmaz veya izlenmez.


Question 8: ".git" klasörünü silersek ne olur?

-> Geçmiş olsun :)
-> ".git" klasörü, bir Git deposunun tüm versiyon kontrolü ve diğer Git özelliklerini içeren çok önemli bir klasördür. Bu klasörü silerseniz, Gitten tüm versiyon kontrolü geçmişi ve diğer Git özelliklerini kaybetmiş olursunuz.
-> ".git" dosyanızı yanlışlıkla silmemek için, gizli dosyaları görüntülemeyi kapatabilirsiniz.


Question 9: Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?

-> İlk olarak template'imizi konumlandıracağımız bir klasör oluşturmamız gerekir.
    -> ~/.git-templates
-> Daha sonra oluşturduğumuz "README.md" dosyayı oluşturduğumuz template dizinine ekliyoruz.
-> Daha sonra her "git init --template ~/.git-templates" komutunu çalıştırdığımızda otomatik olarak Readme.md dosyası oluşmuş olacaktır.


Question 10: Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?

-> Bir projenin farklı paralel geliştirme süreçlerini yönetmek için kullanılır.

    -> Aslında her bir "branch" farklı bir işi farklı bir özelliği temsil eder. Bu da ekip üyelerinin aynı anda farklı özellikler üzerinde çalışmasına olanak tanır.
    -> Yeni bir özellik veya iş üzerinde çalışırken ana yapıyı riske atmadan geliştirmeleri ilerletmemizi sağlar.
    -> Yeni bir özelliğin live a geçmeden(son kullanıcı ile buluşmadan) gerekli testlerin yapılmasına olanak sağlar.
    -> Bir projenin farklı versiyonlarını ve sürümlerini kontrol etmeyi kolaylaştırır. Sürümlerde oluşan hataları bağımsız olarak çözmeyi kolaylaştırır.
    -> Branchlerin birbirinden bağımsız olması nedeni ile yanlış yapılan işlerde değişiklik yapılmasını ve geri alınmasını  kolaylaştırır.


Question 11: Sıfırdan bir "branch" nasıl oluşturabiliriz?

-> git branch test : test adında bir branch oluşturur fakat ilgili branche geçiş yapmaz
-> git checkout -b test : test adında bir branch oluşturur ve test branchine geçiş yapar


Question 12: Var olan bir "branch"e nasıl geçebiliriz?

-> git checkout branchName: bu komut ile var olan bir branche gçiş yapabiliriz


Question 13: "git clone" komutunu kullanırken belirli bir spesifik branch'i sadece çekmek istiyorsak nasıl yapabiliriz?

-> git clone --branch branchName repoUrl: İlgili repoUrl'ine gidip o repoda eğer branchName adında bir branch var ise  sadece o branchi çeker


Question 14: "Merge conflict" ne demektir?

-> Git'te iki veya daha fazla değişikliğin birleştirilmek istendiğinde meydana gelen uyumsuzluktur diyebiliriz.

    -> Eğer iki farklı branchte aynı dosyanın aynı satırında değişiklikler varsa Git bu değişikliklerden hangisini alacağını bilemeyeceği için çakışma durumu oluşur.
    -> Bir branchte silinen bir dosya eğer başka bir branchte düzenlenmişse ortaya çıkar.
    -> İki farklı branchte aynı dosyada farklı satırlarda yer alan değişken veya fonksiyon isimlerinin değiştirilmesi durumunda oluşabilir.
    -> İki farklı branchte aynı dosyanın yerini değiştirildiğinde oluşabilir.


Question 15: "git log" komutu ile hangi bilgileri görebiliriz?

-> Git'te yapılan commit geçmişini gösterir. Her commit için şu bilgileri görebiliriz;

       -> Commit Id(sha)(hash id): Her commit e ait benzersiz kimlik
       -> Yazar ve Tarih Bilgisi: Commit'i kimin yaptığını ve ne zaman yaptığını gösterir. Bu bilgiler, genellikle kullanıcı adı ve e-posta adresiyle birlikte tarih ve saat olarak gösterilir.
       -> Commit Mesajı: Commit'in amacını ve içeriğini açıklar.


Question 16: "git diff" ile kaç farklı iki durumun arasındaki değişiklikleri görebiliriz?

-> Dosyalar üzerindeki değişiklikleri görmemizi sağlar.

    -> Çalışma Dizini ve Staging Area Arasındaki Farklar: Henüz commit edilmemiş (git diff)
    -> Staging Area ve Son Commit Arasındaki Farklar: (git diff --staged veya  git diff --cached)
    -> İki Farklı Commit Arasındaki Farklar: (git diff <commit1> <commit2>)
    -> İki Farklı Branch Arasındaki Farklar: (git diff <branch1> <branch2>)
    -> Mevcut directoryde kaç dosyada ve kaç satırda değişiklik olduğunu verir -> (git diff --stat)


Question 17: Git reset ile neyi geri alıyoruz?

-> Stating areaya eklediğimiz dosyaları Staging areadan geri çıkartır. Fakat o dosyalarda yapılan değişiklikleri geri alma(iptal etme) işlemi değildir.


Question 18: "git commit" ile "git push" arasındaki fark nedir?

-> "git commit": yapılan değişiklikleri lokal depoya (yani bilgisayarınızdaki Git deposuna) kaydeder.
-> "git push": lokal depodaki değişiklikleri uzak bir Git sunucusuna göndermek için kullanılır.


Question 19: Atomic commit ne demektir?

-> Yazılan commit mesajlarının belirli formata göre yazılmasına atomic commit denir.

    ->Örn - feat(api) : "blabla" api bağlantısı eklendi

