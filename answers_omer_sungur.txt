1 -> Git, bir versiyon kontrol sistemidir. Her yapılan adımı versiyonlamamıza olan sağlar. Versiyonlarken birçok özelliği kullanabiliriz.

2 -> git fetch ile uzak sunucudaki değişiklikleri görüntüleyebiliyoruz fakat o değişiklikleri getirmiyoruz. git pull ile o değişkliği getiriyoruz, yani localimize merge ediyoruz. Aslında git pull ile hem fetch işlemini hem de merge işlemini yapmış oluyoruz. Direkt olarak pull yapmak sıkıntılara yol açabilir. Pull durumunda bir conflict oluşmaması için fetch ile güncel haline bakıp karar vermek daha iyi olabilir. Zaten conflict varsa pull işlemi için conflict çözmek gerekiyor ama yine de fetch etmek iyidir.

3 -> Bir conflict durumu oluşmuştur. Aynı satırlarda farklı ifadeler olabilir. Bunları inceleyerek conflicti çözmeliyiz.

4 -> ve her zaman major ifadesini kullanıyormuşuz gibi burada da origin uzak sunucunun adresini veriyor. 

5 -> HEAD, üzerinde bulunduğumuz commit'i ifade eder. Genellikle HEAD, en son commit üzerindedir.

6 -> Staging area, commit atmadan önce yapılan değişiklikleri takip ettiğimiz yerdir.

7 -> Git tarafından takip edilmeyen dosyalara "untracked" file denir. Bunları takip etmek için staging area'ya alırız.

8 -> .git dosyasının içine git ile ilgili bilgiler bulunur. Yani attığımız commitler, staging area'da olan değişiklikler gibi. Bunu silersek bu değişiklikleri ve kontrol mekanizmasını kaybederiz. Kısaca Git'i silmiş oluruz.

9 -> Bunun için git init --template <dosya yolu> komutunu kullanmalıyız. Bu sayede istediğimiz templatelere göre git reposu oluşturulur.

10 -> Versiyon kontrol sisteminde tek bir düzlem isteminde gitmek istemeyebiliriz. Bu yüzden dolayı farklı branchler açarak kendimize özgü bir yolu oluşturabiliriz. Bu sayede diğer branchteki değişiklikler kafamızı karıştırmaz.

11 -> git branch <branch name> komutuyla branch oluşturabiliriz.

12 -> Bunun için switch veya checkout komutlarını kullanabiliriz. git switch <branch name> veya git checkout <branch name>

13 -> git clone -b <branch name> <remote path> şeklinde bir branch'i klonlayabiliriz. Örneğin git clone -b omersungur https://github.com/GokhanOzturkIO/Questions-Git.git

14 -> Eğer ki merge işlemi yaparken iki dosyada çakışma oluyorsa merge conflict oluşur. Yani 2 farklı branch düşünelim ve içlerinde txt dosyasını değiştirelim. Birinci branch'te 5. satıra "aa" yazalım diğer branch'te de aynı satıra, yani 5. satıra "bb" yazalım. Bu durumda bu iki branch merge edilirse conflict oluşur. Çünkü 5.satırda "aa" mı "bb" mi ifadesinin olacağını git kendi bilemez.

15 -> Git log ile atılan commitleri görebiliriz fakat terminal üzerinden sınırlı sayıda gösterebiliyor. Şu an 14 commit attım ve git log yazdığımda sadece 4 commit görebiliyorum. Bütün commitleri görmek istiyorsak git reflog komutunu kullanabiliriz.

16 -> git diff ile hem iki commit arasındaki değişiklikleri görebiliriz hem de iki branch arasındaki değişiklikleri görebiliriz. Örneğin iki commit arasındaki fark için: git diff commit1_id commit2_id yazıp bulabiliriz. git diff main omersungur kullanımında ise main branchi ve omersungur branchi arasındaki farka bakarız.

17 -> git reset ile staging area'da olan değişiklikleri çıkartırız. Bununla değişiklik artık takip edilmez (untracked file).

18 -> Git commit ile localimizde versiyonlama yapıyoruz. Yani atılan commitleri sadece localimizde görebiliyoruz. Bunları uzak sunucuya aktarmak için git push komutunu kullanıyoruz.

19 -> Atomic commit her bir commitin single responsibility kavramına uymasını sağlamak için söylenen bir terimdir. Örneğin bir proje var ve birçok değişiklik yapıyoruz. Her değişiklik tek bir ifade bildirmeli. Yani bir özellik eklediniz bunun commiti atılmalı, bu özellikte bir bug oldu ve çözdüysek bunun ayrı bir commiti atılmalı. Özelliği ekledikten sonra üstüne bir de bug fix yapınca ikisi tek bir commit yapılmamalı. Bu branch'te 3. ve 4. soruların yerini karıştırmıştım ve hem 3. soru eklendi hem de 3'le 4'ün yeri değişti diye commit atmıştım. Bu yanlıştır. Bu ikisi ayrı ayrı commitlenmeli.

20 -> Repository, oluşturulan klasörün kendisidir. İçinde dosyaların bulunduğu bir depo gibi bir şey diyebiliriz.
