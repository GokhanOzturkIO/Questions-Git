1 - Git Nedir?
Git, yazılım geliştirme süreçlerinde kullanılan bir versiyon kontrol sistemidir. Git sayesinde yapacağınız projelerin adım adım versiyonlarının kopyalarını alarak daha sonra ihtiyaç duyduğunuzda aldığınız kopyalara yani versiyonlara kolayca dönebiliyorsunuz.
*****************************************************************
2 - "git pull" ile "git fetch" komutlarının farkı nedir?
Git Fetch ve Git Pull arasındaki temel fark, git fetch’in kaynaktan en yeni meta veri bilgilerini geri yüklemek için yerel git’inizi gösteren komut olmasıdır. Herhangi bir dosya aktarmaz. Daha çok değişikliklerin mevcut olup olmadığını bulmak için verileri incelemek gibidir, oysa git pull tüm değişiklikleri deponuza çekmekle birlikte aynı şeyi yapar

Git fetch, uzaktaki bir deponun dosyalarını, anlık görüntülerini ve referanslarını yerel deponuza indiren bir komuttur. Bu komut, yerel deponuzun mevcut çalışma durumunu güncellemeden uzaktaki verileri indirir, çalışmanızı olduğu gibi bırakır ve getirilen içerik gitcheckout komutu kullanılarak açıkça kontrol edilir.

Öte yandan, git pulls komutu uzaktaki bir depodan verileri getirip indirirken yerel depoyu getirilen verilerle eşleşecek şekilde günceller. Git pulls komutu, git fetch ve git merge komutlarının bir kombinasyonudur, bu nedenle başlangıçta git fetch komutunun işlevini yerine getirir ve daha sonra commit’i birleştirir ve yeni bir merge commit oluşturur.
*****************************************************************
3 - Eğer takım arkadaşımız "kodlarımı gönderdim, benim geliştirmemin üzerine devam et" derse ve gönderdiği kodları "git pull" ile lokalimize alamıyorsak nerelerde hata yapılmış olabilir?
    Uzak Depo (Remote Repository) Hatası:
        Takım arkadaşınızın kodlarını çekmeye çalıştığınız uzak depo (remote repository) bağlantısında bir hata olabilir. Öncelikle, uzak depoyu doğru bir şekilde eklediğinizden ve bağlantının doğru olduğundan emin olun.
        git remote -v komutu ile uzak depo bağlantılarını kontrol edebilirsiniz.

    İzin Sorunları:
        Takım arkadaşınızın kodlarını çekmeye çalıştığınız depoya erişim izinleriniz olmayabilir. Kontrol etmek için depo sahibinden veya yöneticiden gerekli izinleri alın.

    Ağ Sorunları:
        İnternet bağlantınızda bir sorun olabilir. İnternet bağlantınızı kontrol edin ve gerekirse tekrar deneyin.

    Çakışan Değişiklikler:
        Takım arkadaşınızın gönderdiği kodlarla lokaldeki mevcut değişiklikler arasında çakışmalar olabilir. Bu durumda önce lokaldeki değişiklikleri commit etmeniz ve ardından tekrar git pull yapmanız gerekebilir.

    Uzak Depoda Değişiklik Yoksa:
        Takım arkadaşınızın kodlarını gönderdiği branch'te (dal) herhangi bir değişiklik olmayabilir. Belirtilen branch'te yeni bir commit yapıldığından emin olun.

    Doğru Branch Üzerinde Çalıştığınızdan Emin Olun:
        Takım arkadaşınız hangi branch üzerinde çalıştıysa, siz de aynı branch üzerinde olduğunuzdan emin olun. git branch ve git status komutları bu bilgiyi sağlayabilir.

    Alternatif Olarak "git fetch" ve "git merge" Kullanımı:
        git pull yerine önce git fetch ile uzak depodan güncel bilgileri çekip, ardından git merge ile yereldeki branch ile birleştirmeyi deneyebilirsiniz.

Bu adımları kontrol ettikten sonra sorun hala devam ediyorsa, daha fazla ayrıntıya ihtiyaç duyabilirsiniz. Takım arkadaşınızın kullandığı Git versiyonu, sizin kullandığınız Git versiyonu, ve yaşanan hata mesajları gibi bilgilerle daha spesifik bir yardım alabilirsiniz.
*****************************************************************
4 - "git fetch origin" komutundaki "origin" neye karşılık gelmektedir?
git fetch origin komutundaki "origin", genellikle uzak depoyu temsil eden bir kısaltmadır. Bu kısaltma, projenin bağlı olduğu uzak depoyu tanımlar. "origin" genellikle bir depo adıdır ve varsayılan olarak Git tarafından kullanılan isimdir.

Uzak depolar, projenin orijinal kaynaklarının (genellikle bir sunucu veya uzak depo sağlayıcısı) bulunduğu yerlerdir. "origin" terimi, genellikle projenin orijinal kaynaklarını ifade eden varsayılan isimdir, ancak projenin bağlı olduğu uzak depo başka bir isimle de tanımlanabilir.

Örneğin, bir projeyi GitHub'da barındırıyorsanız, "origin" genellikle projenin GitHub'daki uzak depo adresini temsil eder. Ancak, bu isim değiştirilebilir ve projenin bağlı olduğu farklı bir uzak depo için özel bir isim de atanabilir.

Bu nedenle, git fetch origin komutu, "origin" adlı uzak depodan (genellikle varsayılan olarak tanımlanan uzak depo) projenin yerel kopyasına güncel bilgileri çeker.
*****************************************************************
5 - "HEAD" kelimesi neyi temsil etmektedir?
HEAD kelimesi, Git'te mevcut çalışma konumunu (konumunu) temsil eden bir referanstır. HEAD, projenin hangi commit üzerinde çalıştığını gösterir. HEAD bir işaretçi olarak düşünülebilir ve genellikle bir branch adını veya doğrudan bir commit'in SHA-1 özeti gibi bir commit referansını gösterir.

HEAD'in temsil ettiği konum, genellikle şu durumları içerebilir:

    Branch Adı:
        Eğer bir branch üzerinde çalışılıyorsa, HEAD o branch'in adını gösterir. Örneğin, HEAD'in "main" veya "feature-branch" gibi bir ismi olabilir.

    Commit SHA-1 Özeti:
        Eğer doğrudan bir commit üzerinde çalışılıyorsa, HEAD o commit'in SHA-1 özetini gösterir. Bu durumda, kullanıcı bir branch üzerinde değil, belirli bir commit üzerinde çalışıyor demektir.

    Detached HEAD Durumu:
        Eğer kullanıcı bir branch üzerinde değil de doğrudan bir commit üzerinde çalışıyorsa, bu duruma "detached HEAD" denir. HEAD o zaman bir branch adı değil, bir commit'in SHA-1 özetini gösterir.

HEAD'in bulunduğu konum, genellikle mevcut işlemlerin (commit, merge, vb.) etkileşimde bulunacağı yerdir. Bu nedenle, HEAD konumunu bilmek, projedeki çalışma durumu hakkında bilgi sağlar. git log, git status ve benzeri komutlar HEAD konumunu gösterir ve kullanıcılara projenin geçmişi ve mevcut durumu hakkında bilgi sağlar.
*****************************************************************
6 - "Staging Area" ya da "Index" diye isimlendirilen bölge tam olarak ne demektir?
Staging Area (Hazırlık Alanı): Bu, üzerinde değişiklik yaptığımız dosyaları Git’e göndermeye hazırladığımız alandır. Bu alan dosyaların veri tabanına yazılmadan önceki son aşamasıdır ve bu aşamada Git, dosyalarda herhangi bir çakışma (Dif) olup olmadığına bakar. Bu alan ayrıca hangi dosyaların sürüm yedeğine alınıp alınmayacağını da belirlediğimiz alandır. Buraya eklediğimiz dosyalar bir sonraki Tahüt (Commit) işleminde yedeklenecek dosyaları oluşturur.
İndex (Dizin): Bu, projemizde sürümler hâlinde tutulan dosyalarımızın bulunduğu alandır. Bu alanda yer alan dosyalar dosya halinden ziyade, Snapshot (anlık görüntü) durumundadır ve bu sayede bizler istediğimiz sürüme kolaylıkla geri dönebiliriz.
*****************************************************************
7 - "Untracked file" ne demektir?
Untracked basitçe Git'in önceki anlık görüntüde sahip olmadığınız bir dosyayı gördüğü anlamına gelir. Yani commit etmedikçe Git onu untracked file olarak görecektir. Bunu, oluşturulan binary dosyaları veya dahil etmek istemediğiniz diğer dosyaları yanlışlıkla dahil etmeye başlamamanız için yapar. yenidosya'yı dahil etmek için track etmeye başlamamız lazım. Yeni dosyayı tracking'e başlamak için git add komutunu kullanmalıyız. git add komutu, bir dosya veya dizin için bir yol adı alır; bu bir dizinse, komut o dizindeki tüm dosyaları tekrar tekrar ekler.
"Untracked file" ifadesi, Git'in sürüm kontrolü altına almadığı, izlemediği ve takip etmediği dosyaları ifade eder.
*****************************************************************
8 - ".git" klasörünü silersek ne olur?
.git klasörü, bir Git deposunun temelini oluşturan ve depo ile ilgili tüm bilgileri içeren kritik bir klasördür. Eğer .git klasörünü silerseniz, Git deposu ile ilgili tüm geçmiş, branch bilgileri, commitler, takip edilen dosyalar ve diğer sürüm kontrolü bilgileri kaybolur. Bu, projenin Git sürüm kontrolü altında olmaktan çıkmasına ve tüm geçmiş bilgilerinin kaybolmasına neden olur.
İşte .git klasörünü silmenin olası sonuçları:
    Tüm Geçmiş ve Commit Bilgileri Kaybolur:
        .git klasörü, projenin tüm geçmişini, commit bilgilerini ve branch yapılarını içerir. Bu bilgiler silindiğinde, projenin geçmişi tamamen kaybolur ve geri getirilemez.
    Branch Bilgileri Kaybolur:
        Branch'ler, .git klasörü içinde saklanan bilgilerle ilişkilidir. Bu bilgileri silmek, projedeki branch'lerin ve branch'e ait commit bilgilerinin kaybolmasına neden olur.
    Takip Edilen Dosyalar Kaybolur:
        Git, takip edilen dosyaların durumunu ve değişikliklerini kontrol etmek için .git klasörünü kullanır. Klasörü sildiğinizde, Git bu dosyaları takip etmeyi bırakır.
    Tüm Konfigürasyon Ayarları Kaybolur:
        .git klasörü, projeye özgü Git konfigürasyon ayarlarını içerir. Bu ayarlar silindiğinde, projeye özgü Git konfigürasyonu kaybolur.
Bu nedenle, .git klasörünü silmek, projenin Git sürüm kontrolü altında olmaktan çıkmasına ve tüm geçmiş bilgilerinin kaybolmasına neden olur. Bu işlem geri dönüşü zor bir değişikliktir. Eğer projenin sürüm geçmişi ve Git ile ilgili bilgiler önemliyse, .git klasörünü silmekten kaçınılmalıdır.
*****************************************************************
9 - Kendi lokalimizde her "git init" komutunu kullanıdığımızda otomatik olarak "ReadMe.md" dosyası oluşturulmasını istiyorsak ne yapmalıyız?
    Bir metin düzenleyici ile yeni bir dosya oluşturun ve içine aşağıdaki Bash betiğini ekleyin. Örneğin, init-script.sh olarak adlandırabilirsiniz:

bash

#!/bin/bash

# Git depo oluştur
git init

# ReadMe.md dosyasını oluştur
echo "# Project Title" > ReadMe.md
echo "This is the initial README file." >> ReadMe.md

# İlk commit'i yap
git add ReadMe.md
git commit -m "Initial commit with ReadMe.md"

    Betiği çalıştırabilir ve projenizi başlatabilirsiniz:

bash

bash init-script.sh

Bu betik, git init komutunu kullanarak bir Git deposu oluşturur ve ardından ReadMe.md dosyasını başlangıç içeriğiyle birlikte oluşturup ilk commit'i yapar. Bu şekilde, her defasında bir Git deposu başlatırken otomatik olarak bir ReadMe.md dosyası oluşturabilirsiniz.

Unutmayın ki, bu sadece bir örnek betiktir ve ihtiyaçlarınıza göre özelleştirebilirsiniz. Bu tür bir otomatikleştirme, projenizin başlangıcında belirli bir standart dosya veya yapı oluşturmak istediğiniz durumlarda kullanışlı olabilir.
*****************************************************************
10 - Git konusunda bahsi geçen "branch" yapısı nedir? Bize ne sağlar?
Git'te "branch" (dal) kavramı, projenin farklı paralel geliştirme hatlarını temsil eden, birbirinden bağımsız iş akışlarını sağlayan bir yapıdır. Bir projede birden fazla geliştirici veya geliştirme hattı olduğunda, bu dallar aynı kaynak kod tabanını paylaşabilir ancak bağımsız olarak ilerleyebilirler. Bu, her bir dalın kendi değişikliklerini ve geçmişini takip etmesine, test etmesine ve birleştirmesine olanak tanır.

İşte Git branch yapısının sağladığı bazı avantajlar:

    Paralel Geliştirme:
        Birden fazla geliştirici aynı anda farklı özellikler üzerinde çalışabilir. Her bir geliştirici kendi dalında değişiklikler yapabilir ve bu değişiklikleri bağımsız olarak teste tabi tutabilir.

    İzole Değişiklikler:
        Branch'lar, değişiklikleri izole eder. Bu, bir dalda yapılan değişikliklerin diğer dalları etkilememesini ve test aşamasında çakışma olasılığını azaltır.

    Geliştirme Süreçlerinin Organizasyonu:
        Branch'lar, projenin farklı bölümleri veya özellikleri üzerinde çalışmayı organize etmeye yardımcı olur. Örneğin, bir branch yeni bir özellik eklemeye odaklanabilir, bir diğer branch hata düzeltmeleri üzerine çalışabilir.

    Risk Yönetimi:
        Her bir dal, belirli bir özellik veya düzeltme üzerinde çalıştığından, bir dalın başarısız olması veya sorun çıkması durumunda diğer dallar etkilenmez. Bu, riskin yayılmasını engeller.

    Geri Alma ve Değişiklik Yönetimi:
        Dal, bir özellik tamamlanmadan önce veya hatalar giderilmeden önce ana dalda (genellikle "main" veya "master") değişikliklerin birleştirilmesini engeller. Bu, kontrolsüz veya eksik özelliklerin ana dalı etkilemesini önler.

Git'te yaygın olarak kullanılan komutlar arasında git branch (dalları listeleme), git checkout (dal değiştirme), git merge (dalları birleştirme) ve git push (dalı uzak depoya gönderme) gibi komutlar, branch yönetimini kolaylaştırmak için kullanılır. Branch'lar, geliştirme sürecini daha organize, izlenebilir ve etkili hale getirir.
*****************************************************************
11 - Sıfırdan bir "branch" nasıl oluşturabiliriz?
Örnek:
git branch yeni-branch-adı
*****************************************************************
12 - Var olan bir "branch"e nasıl geçebiliriz?
git checkout yeni-branch-adı
veya
git switch yeni-branch-adı
*****************************************************************
13 - "git clone" komutunu kullanırken belirli bir spesifik branch'i sadece çekmek istiyorsak nasıl yapabiliriz?
Eğer belirli bir spesifik branch'i sadece çekmek istiyorsanız, git clone komutunu kullandıktan sonra git checkout komutu ile ilgili branch'e geçebilirsiniz.
git clone <uzak_depo_adresi> ve ardından cd ile ilgili dizine gidilir
git checkout <branch_adi> ile istenen bracnh'e geçiş yapılabilir.
*****************************************************************
14 - "Merge conflict" ne demektir?
"Merge conflict" (birleştirme çakışması), Git'in otomatik birleştirme (merge) işlemi sırasında iki farklı kaynaktan gelen değişikliklerin çakışması durumunu ifade eder. Bu durum, aynı dosyanın aynı satırlarının farklı branch'lerde farklı şekillerde değiştirilmiş olması anlamına gelir.
Merge conflict'ler, genellikle şu durumlarda ortaya çıkar:
    Aynı Satırın İki Farklı Yerde Değiştirilmesi:
        İki farklı branch'te aynı dosyanın aynı satırları üzerinde değişiklik yapılırsa, birleştirme sırasında Git çakışmayı tespit eder.
    Dosyanın İki Farklı Yerde Taşınması veya Silinmesi:
        İki branch'te aynı dosyanın farklı yerlerinde taşıma veya silme işlemi gerçekleşirse, Git çakışma bildirir.
    Farklı İsimlendirilmiş Dosyaların Değiştirilmesi:
        İki branch'te farklı isimlendirilmiş ama aynı içeriğe sahip dosyaların değiştirilmesi durumunda Git çakışma tespit eder.
    Bir Dalın Diğerine Birleştirilmesi İşleminin İki Trafikten Birden Gerçekleştirilmesi:
        İki geliştirici, aynı ana branştan farklı branch'leri üzerinde çalışır ve sonra bu değişiklikleri ana branch'e birleştirme işlemini yaparsa, çakışma yaşanabilir.
Merge conflict durumunda, Git otomatik birleştirme yapamaz ve kullanıcıya çakışan değişiklikleri çözmesi için yardım ister. Kullanıcı, çakışan dosyaları düzenleyip, çözümleri belirleyerek manuel olarak birleştirme işlemini tamamlar. Çakışmayı çözdükten sonra kullanıcı, değişiklikleri tekrar işleme koyar ve birleştirme işlemi tamamlanır.
*****************************************************************
15 - "git log" komutu ile hangi bilgileri görebiliriz?
git log komutu, bir Git deposundaki commit geçmişini görüntülemek için kullanılır. Bu komut, geçmişte yapılmış commit'leri, commit'lerin özet bilgilerini ve ilgili diğer detayları gösterir. git log komutu kullanıldığında görülebilecek başlıca bilgiler şunlardır:
Commit Hash (SHA-1), Author (Yazar) ve Committer (Taşıyıcı), Tarih ve Saat Bilgisi, Commit Mesajı, Gövde (Body) ve Altbilgi (Footer) Bilgileri, Değişiklikleri Gösteren İstatistikler, Bağlantılı Branch ve Tag Bilgileri.
*****************************************************************
16 - "git diff" ile kaç farklı iki durumun arasındaki değişiklikleri görebiliriz?
İki Commit Arasındaki Değişiklikleri Görebiliriz, Branch'ler Arasındaki Değişiklikleri Görebiliriz, Çalışma Dizini ile Son Commit Arasındaki Değişiklikleri Görebiliriz, Belirli Bir Dosyanın Değişikliklerini Görebiliriz.
*****************************************************************
17 - Git reset ile neyi geri alıyoruz?
git reset komutu, Git deposundaki commit geçmişi, çalışma dizini ve index (staging alanı) üzerinde geri alma işlemlerini gerçekleştiren bir komuttur. 
*****************************************************************
18 - "git commit" ile "git push" arasındaki fark nedir?
git commit komutu, çalışma dizinindeki değişiklikleri bir commit haline getirir. git push komutu, yerel depodaki (local repository) commit'leri uzak depoya (remote repository) göndermek için kullanılır. Yerel depodaki commit'lerin uzak depoda paylaşılmasını sağlar.Sonuç olarak, git commit değişiklikleri yerel depoya kaydederken, git push de yerel depodaki commit'leri uzak depoya gönderir ve diğer geliştiricilerle veya depo paylaşımı yapılan bir platformla (GitHub, GitLab, vb.) senkronize olmanızı sağlar. Her iki komut da farklı aşamalarda kullanılır ve iş akışının düzenli ve işlevsel olmasını sağlar.
*****************************************************************
19 - Atomic commit ne demektir?
"Atomic commit" bir versiyon kontrol sistemi (VCS) kullanılırken yapılan bir commit işleminin, bir değişiklik grubunun tamamını içermesi ve bu değişiklik grubunun bir bütün olarak işlenmesi anlamına gelir. Atomik commit'ler, bir değişiklik setinin parçalara bölünmeden tamamen uygulandığı ve kaydedildiği bir commit yaklaşımını temsil eder.
*****************************************************************
20 - Repository ne demektir?
Bir yazılım projesinin, belgelerin, kaynak kodunun, dosyaların ve projeye ait diğer materyallerin depolandığı yerdir. 
*****************************************************************
21 - "git tag" nedir? "git branch"’ten farkı nedir?
git tag komutu, bir belirteci (tag) belirli bir commit'e atamak veya gösterilen commit için bir etiket oluşturmak için kullanılır. Genellikle, bir projenin belirli bir sürümünü veya önemli bir noktasını işaretlemek için tag'ler kullanılır. Tag'ler, genellikle sürüm numaralarını (örneğin, "v1.0") veya projenin belirli bir aşamasını temsil eden açıklamaları içerir. Tag'ler, commit'ler üzerine eklenir ve bu commit'in belirli bir noktasını işaretler.
git branch komutu, projede farklı iş akışlarını veya geliştirme dallarını temsil eden branch'leri oluşturmak ve yönetmek için kullanılır. Branch'ler, projede paralel geliştirmelerin veya farklı özelliklerin üzerinde çalışmanın bir yolunu sağlar. Her branch, kendi bağımsız commit geçmişine sahiptir.
*****************************************************************
22 - Git'i görsel olarak kullanabilmek için hangi üçüncü taraf araçları ve uygulamaları kullanabiliriz?
GitHub Desktop, SourceTree, GitKraken, GitExtensions
*****************************************************************

